#if FLOATS_ENABLED
#if COMPLEX_ENABLED
using System;

namespace Anathema.Vectors.Core
{
    //WARNING: Implementation generated by AI and not tested yet.
    /// <summary>
    /// Single precision floating point complex number
    /// </summary>
    public class com
    {
        public override bool Equals(object o)
        {
            if (o is com)
                return ((com)o) == this;
            else
                return false;
        }
        public float real { get; set; }
        public float imaginary { get; set; }

        public com()
        {

        }
        public com(float real, float imaginary) {
            this.real = real;
            this.imaginary = imaginary;
        }

        public com(float[] ri)
        {
            this.real = ri[0];
            this.imaginary = ri[1];
        }

        public static com operator +(com a, com b) {
            return new com(a.real + b.real, a.imaginary + b.imaginary);
        }
        public static com operator -(com a, com b)
        {
            return new com(a.real - b.real, a.imaginary - b.imaginary);
        }
        public static com operator *(com a, com b)
        {
            return new com((a.real * b.real) - (a.imaginary * b.imaginary),
                (a.real * b.imaginary) + (b.real * a.imaginary));
        }
        public static com operator /(com a, com b)
        {
            float denom = b.real * b.real + b.imaginary * b.imaginary;
            return new com(
                ((a.real * b.real) + (a.imaginary * b.imaginary)) / denom,
                ((a.imaginary * b.real) - (a.real * b.imaginary)) / denom
            );
        }
        public static com operator +(com a, float b)
        {
            return new com(a.real + b, a.imaginary);
        }
        public static com operator -(com a, float b)
        {
            return new com(a.real - b, a.imaginary);
        }
        public static com operator *(com a, float b)
        {
            return new com(a.real * b, a.imaginary * b);
        }
        public static com operator /(com a, float b)
        {
            return new com(a.real / b, a.imaginary / b);
        }

        public static com operator +(float a, com b)
        {
            return new com(a + b.real, b.imaginary);
        }
        public static com operator -(float a, com b)
        {
            return new com(a - b.real, -b.imaginary);
        }
        public static com operator *(float a, com b)
        {
            return new com(a * b.real, a * b.imaginary);
        }
        public static com operator /(float a, com b)
        {
            float denom = b.real * b.real + b.imaginary * b.imaginary;
            return new com(
                (a * b.real) / denom,
                (-a * b.imaginary) / denom
            );
        }


        public static bool operator !=(com a, com b)
        {
            return !(a == b);
        }
        public static bool operator ==(com a, com b)
        {
            if (!(a is null) && b is null)
                return false;
            if (a is null && !(b is null))
                return false;
            if (a is null && b is null)
                return true;
            return scalar.isClose(a.real, b.real) && scalar.isClose(a.imaginary, b.imaginary);
        }
    }
}
#endif
#endif